"""
Script to execute Prolific submission actions based on a review plan using completion codes.

This script reads a `review_plan.csv` file (generated by
`generate_review_plan.py` and subsequently reviewed by the user).
It then iterates through the plan and performs the specified actions
(APPROVE, REJECT, or COMPLETE with completion codes) via the Prolific API.

Assumes:
- `config.py` and `prolific_utils.py` are in the project root directory.
- `review_plan.csv` is in the project root (or path is specified).
- This script is run from the project root.

Prerequisites:
1.  A `review_plan.csv` file, typically in the project root.
    Must contain columns: 'prolific_submission_id', 'proposed_action',
    and 'completion_code' for COMPLETE actions.
2.  Python `requests` library installed.

Usage:
    python "Python files/Approval and rejection/execute_prolific_actions.py"
    The script will prompt for the path to the review plan CSV.
"""

import sys
import os
import csv
import time

# Adjust sys.path to import modules from the parent directory
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PARENT_DIR = os.path.dirname(SCRIPT_DIR)
if PARENT_DIR not in sys.path:
    sys.path.append(PARENT_DIR)

# --- Define Project Root relative to this script ---
# This allows the script to be run from any directory
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, "../../../../../../"))

import prolific_utils # Should now find prolific_utils.py in the project root
import config

# Import completion codes configuration
try:
    sys.path.append(os.path.dirname(__file__))
    from completion_codes_config import get_api_action_for_completion_code, get_code_name, COMPLETION_CODES
except ImportError:
    print("ERROR: Could not import completion_codes_config.py. Make sure it's in the same directory as this script.")
    sys.exit(1)

# --- Configuration --- #
PLAN_COL_SUBMISSION_ID = "prolific_submission_id"
PLAN_COL_PROPOSED_ACTION = "proposed_action"
PLAN_COL_COMPLETION_CODE = "actual_completion_code"
PLAN_COL_REASON = "decision_reason"  # For logging purposes

ACTION_APPROVE = "APPROVE"
ACTION_REJECT = "REJECT"
ACTION_COMPLETE = "COMPLETE"

BASE_SLEEP_TIME = 0.5  # Starting sleep time for exponential backoff
MAX_RETRIES = 3  # Maximum retries for rate limiting
# --------------------- #

def transition_single_submission(submission_id, action, completion_code=None, reason=None, retry_count=0):
    """
    Transitions a single Prolific submission using the appropriate action.
    Includes retry logic for rate limiting.
    """
    print(f"\nProcessing Submission ID: {submission_id}, Action: {action}")
    endpoint = f'/submissions/{submission_id}/transition/'
    payload = {"action": action.upper()}

    if action.upper() == ACTION_COMPLETE:
        if not completion_code:
            print(f"  ERROR: For COMPLETE action, completion_code must be provided. Got: '{completion_code}'")
            return False
        payload["completion_code"] = completion_code
        print(f"  Using completion code: {completion_code}")
    elif action.upper() == ACTION_REJECT:
        if not reason or len(reason) < 100:
            print(f"  ERROR: For REJECT, reason must be >= 100 chars. Got: '{reason}'")
            return False
        payload["message"] = reason
        payload["rejection_category"] = "OTHER"  # Default category for manual rejections
    elif action.upper() != ACTION_APPROVE:
        print(f"  ERROR: Unsupported action '{action}'. Only '{ACTION_APPROVE}', '{ACTION_REJECT}', or '{ACTION_COMPLETE}' supported.")
        return False

    try:
        api_response = prolific_utils.make_api_request(method='POST', endpoint=endpoint, json_data=payload)
        
        # Handle rate limiting with retry
        if api_response and hasattr(api_response, 'status_code') and api_response.status_code == 429:
            if retry_count < MAX_RETRIES:
                backoff_time = BASE_SLEEP_TIME * (2 ** retry_count)  # Exponential backoff
                print(f"  Rate limited. Retrying in {backoff_time} seconds... (attempt {retry_count + 1}/{MAX_RETRIES})")
                time.sleep(backoff_time)
                return transition_single_submission(submission_id, action, completion_code, reason, retry_count + 1)
            else:
                print(f"  ERROR: Rate limited and max retries ({MAX_RETRIES}) exceeded.")
                return False

        if api_response and 'status' in api_response:
            print(f"  SUCCESS: Sub {submission_id} status -> {api_response.get('status')}.")
            return True
        else:
            print(f"  FAILURE: Sub {submission_id} transition failed or API response unexpected.")
            return False
            
    except Exception as e:
        print(f"  ERROR: API request failed: {e}")
        return False

def bulk_screen_out_submissions(study_id, submission_ids):
    """
    Screen out multiple submissions using Prolific's bulk screen out endpoint.
    """
    print(f"\nBulk screening out {len(submission_ids)} submissions...")
    endpoint = f'/studies/{study_id}/screen-out-submissions/'
    payload = {
        "submission_ids": submission_ids,
        "increase_places": True  # Increase available places for new participants
    }

    try:
        api_response = prolific_utils.make_api_request(method='POST', endpoint=endpoint, json_data=payload)
        
        if api_response:
            print(f"  SUCCESS: Bulk screen out request submitted for {len(submission_ids)} submissions.")
            return True
        else:
            print(f"  FAILURE: Bulk screen out request failed.")
            return False
            
    except Exception as e:
        print(f"  ERROR: Bulk screen out API request failed: {e}")
        return False

def execute_actions_from_plan(plan_filepath):
    """
    Reads the review plan CSV and executes the specified actions based on completion codes.
    """
    actions_to_execute = []
    submissions_to_screen_out = []
    
    try:
        with open(plan_filepath, mode='r', encoding='utf-8', newline='') as infile:
            reader = csv.DictReader(infile)
            required_cols = [PLAN_COL_SUBMISSION_ID, PLAN_COL_PROPOSED_ACTION]
            if not all(col in reader.fieldnames for col in required_cols):
                print(f"ERROR: Plan CSV must have columns: {required_cols}. Found: {reader.fieldnames}")
                return

            for row_num, row in enumerate(reader, 1):
                submission_id = row.get(PLAN_COL_SUBMISSION_ID, '').strip()
                action = row.get(PLAN_COL_PROPOSED_ACTION, '').strip().upper()
                completion_code = row.get(PLAN_COL_COMPLETION_CODE, '').strip()
                reason = row.get(PLAN_COL_REASON, '').strip()

                if not submission_id:
                    print(f"Warning: Skipping row {row_num} in plan (missing submission ID).")
                    continue

                # Determine the correct action based on completion code
                if completion_code:
                    api_action = get_api_action_for_completion_code(completion_code)
                    
                    if api_action == "SKIP":
                        print(f"Info: Row {row_num} (Sub {submission_id}): Code {completion_code} auto-processes -> SKIPPED.")
                        continue
                    elif api_action == "SCREEN_OUT":
                        submissions_to_screen_out.append({
                            "submission_id": submission_id,
                            "completion_code": completion_code,
                            "row_num": row_num
                        })
                        print(f"Info: Row {row_num} (Sub {submission_id}): Code {completion_code} -> SCREEN_OUT.")
                        continue
                    elif api_action == "REJECT":
                        # Use reject action with appropriate reason
                        reject_reason = f"Based on completion code {completion_code} ({get_code_name(completion_code)}): "
                        if completion_code == COMPLETION_CODES["FAILED_ATTENTION"]:
                            reject_reason += "Participant failed attention checks indicating insufficient attention to study requirements."
                        elif completion_code == COMPLETION_CODES["NO_CONSENT"]:
                            reject_reason += "Participant did not provide valid consent to participate in this research study."
                        else:
                            reject_reason += "Participant did not meet study requirements."
                        
                        actions_to_execute.append({
                            "submission_id": submission_id, 
                            "action": ACTION_REJECT,
                            "completion_code": completion_code,
                            "reason": reject_reason, 
                            "row_num": row_num
                        })
                        continue
                    else:
                        print(f"Warning: Row {row_num} (Sub {submission_id}): Unknown completion code {completion_code} -> MANUAL_REVIEW needed.")
                        continue
                
                # Fallback for old logic (if no completion code)
                if action in [ACTION_APPROVE, ACTION_REJECT, ACTION_COMPLETE]:
                    actions_to_execute.append({
                        "submission_id": submission_id, 
                        "action": action,
                        "completion_code": completion_code,
                        "reason": reason, 
                        "row_num": row_num
                    })
                elif action.startswith("COMPLETE"):
                    # Handle variations like COMPLETE_BUT_VERIFY_MISMATCH - still execute as COMPLETE
                    actions_to_execute.append({
                        "submission_id": submission_id, 
                        "action": ACTION_COMPLETE,
                        "completion_code": completion_code,
                        "reason": reason, 
                        "row_num": row_num
                    })
                    print(f"Info: Row {row_num} (Sub {submission_id}): Action '{action}' -> Treating as COMPLETE.")
                elif action.startswith("NO_ACTION") or action.startswith("MANUAL_REVIEW"):
                    print(f"Info: Row {row_num} (Sub {submission_id}): Action '{action}' -> SKIPPED.")
                else:
                    print(f"Warning: Row {row_num} (Sub {submission_id}): Unrecognized action '{action}' -> SKIPPED.")

        if not actions_to_execute and not submissions_to_screen_out:
            print("No valid actions to execute found in the review plan.")
            return

        total_actions = len(actions_to_execute) + len(submissions_to_screen_out)
        print(f"\nFound {total_actions} actions to execute from '{plan_filepath}'.")
        
        # Show summary
        action_summary = {}
        for item in actions_to_execute:
            action_key = item["action"]
            if action_key == ACTION_REJECT:
                action_key += f" ({get_code_name(item['completion_code'])})"
            action_summary[action_key] = action_summary.get(action_key, 0) + 1
        
        if submissions_to_screen_out:
            screen_out_codes = [item["completion_code"] for item in submissions_to_screen_out]
            action_summary[f"SCREEN_OUT ({', '.join(set(screen_out_codes))})"] = len(submissions_to_screen_out)
        
        print("\nAction Summary:")
        for action_type, count in action_summary.items():
            print(f"  {action_type}: {count}")
        
        confirm = input("\nProceed with executing these actions on Prolific? (yes/no): ").strip().lower()
        if confirm != 'yes':
            print("Execution aborted by user.")
            return

        print("\n--- EXECUTING ACTIONS ---")
        all_successful = True
        action_count = 0
        
        # 1. Execute bulk screen out first (if any)
        if submissions_to_screen_out:
            action_count += 1
            print(f"Action {action_count}/{total_actions} - Bulk Screen Out")
            submission_ids = [item["submission_id"] for item in submissions_to_screen_out]
            
            # Get study ID from config for bulk screen out
            study_id = config.PROLIFIC_STUDY_ID
            
            success = bulk_screen_out_submissions(study_id, submission_ids)
            if not success:
                all_successful = False
            
            if action_count < total_actions:
                print(f"  Waiting 2.0s before next actions...")
                time.sleep(2.0)
        
        # 2. Execute individual actions (rejects, etc.)
        for i, item in enumerate(actions_to_execute):
            action_count += 1
            print(f"Action {action_count}/{total_actions} (Plan row {item['row_num']})")
            success = transition_single_submission(
                submission_id=item["submission_id"],
                action=item["action"],
                completion_code=item["completion_code"],
                reason=item["reason"]
            )
            if not success:
                all_successful = False

            if action_count < total_actions:
                # Exponential backoff between API calls
                sleep_time = BASE_SLEEP_TIME * (1.5 ** min(i, 10))
                print(f"  Waiting {sleep_time:.1f}s before next action...")
                time.sleep(sleep_time)
        
        print("\n--- EXECUTION SUMMARY ---")
        if all_successful:
            print("All planned actions completed successfully.")
        else:
            print("Some actions may have failed. Review logs above.")

    except FileNotFoundError:
        print(f"ERROR: Review plan CSV file not found at '{plan_filepath}'")
    except Exception as e:
        print(f"ERROR: Could not process review plan file '{plan_filepath}'. Error: {e}")

if __name__ == "__main__":
    print("--- Starting Prolific Action Execution Script (Completion Codes) ---")
    
    # The script will now directly use the 'review_plan_with_validation.csv' file
    # generated by the previous script, without prompting.
    plan_filename = "review_plan_with_validation.csv"
    plan_csv_path = os.path.join(PROJECT_ROOT, plan_filename)
    
    print(f"Using review plan: {plan_csv_path}")

    if not os.path.exists(plan_csv_path):
        print(f"ERROR: Review plan file not found at '{plan_csv_path}'")
        print("Please ensure you have run 'generate_review_plan.py' first.")
        sys.exit(1)
    
    execute_actions_from_plan(plan_csv_path)

    print("--- Prolific Action Execution Script Finished ---") 